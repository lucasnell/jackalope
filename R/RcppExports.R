# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Merge a reference genome into a single sequence.
#'
#'
#' @param ref_genome_ An external pointer (R class \code{externalptr}) to a
#'     \code{RefGenome} class in C++ (the full class in C++ is
#'     \code{Rcpp::XPtr<RefGenome>}).
#'
#' @return Nothing. Changes are made in place.
#'
#' @name merge_sequences
#'
#' @noRd
#'
merge_sequences <- function(ref_genome_) {
    invisible(.Call(`_gemino_merge_sequences`, ref_genome_))
}

#' Filter reference genome sequences by size or for a proportion of total nucleotides.
#'
#'
#' @inheritParams ref_genome_ merge_sequences
#' @param min_seq_size Integer minimum sequence size to keep.
#'     Defaults to \code{0}, which results in this argument being ignored.
#' @param out_seq_prop Numeric proportion of total sequence to keep.
#'     Defaults to \code{0}, which results in this argument being ignored.
#'
#' @return Nothing. Changes are made in place.
#'
#' @name filter_sequences
#'
#' @noRd
#'
#'
filter_sequences <- function(ref_genome_, min_seq_size = 0L, out_seq_prop = 0) {
    invisible(.Call(`_gemino_filter_sequences`, ref_genome_, min_seq_size, out_seq_prop))
}

#' Create `RefGenome` pointer based on nucleotide equilibrium frequencies.
#'
#' Function to create random sequences for a new reference genome object.
#'
#' Note that this function will never return empty sequences.
#'
#' @param n_seqs Number of sequences.
#' @param len_mean Mean for the gamma distribution for sequence sizes.
#' @param len_sd Standard deviation for the gamma distribution for sequence sizes.
#'     If set to `<= 0`, all sequences will be the same length. Defaults to `0`.
#' @param pi_tcag Vector of nucleotide equilibrium frequencies for
#'     "T", "C", "A", and "G", respectively. Defaults to `rep(0.25, 4)`.
#' @param n_cores Number of cores to use via OpenMP.
#'
#'
#' @return External pointer to a `RefGenome` C++ object.
#'
#' @export
#'
#' @examples
#'
#' genome <- create_genome(10, 100e3, 100, pi_tcag = c(0.1, 0.2, 0.3, 0.4))
#'
create_genome <- function(n_seqs, len_mean, len_sd = 0, pi_tcag = numeric(0), n_cores = 1L) {
    .Call(`_gemino_create_genome`, n_seqs, len_mean, len_sd, pi_tcag, n_cores)
}

#' Create random sequences as a character vector.
#'
#' This function is used internally for testing.
#'
#'
#' @inheritParams create_genome
#'
#' @return Character vector of sequence strings.
#'
#'
#' @noRd
#'
rando_seqs <- function(n_seqs, len_mean, len_sd = 0, pi_tcag = numeric(0), n_cores = 1L) {
    .Call(`_gemino_rando_seqs`, n_seqs, len_mean, len_sd, pi_tcag, n_cores)
}

#' Calculate how many bases come before a cleavage site.
#'
#'
#' @noRd
#'
get_precleavage_lens <- function(seqs) {
    .Call(`_gemino_get_precleavage_lens`, seqs)
}

#' Expand sequences for reverse complements and for non-specific nucleobases.
#'
#'
#' @noRd
#'
expand_seqs <- function(seqs) {
    .Call(`_gemino_expand_seqs`, seqs)
}

#' Internal C++ function to digest all sequences for all variants in a variant set.
#'
#'
#'
#' @param var_set_ An external pointer to a C++ \code{VarSet} object
#'     representing variants from the reference genome.
#' @inheritParams bind_sites digest_ref
#' @inheritParams len5s digest_ref
#' @param chunk_size The size of chunks to divide sequences into when digesting.
#' @param n_cores The number of cores to use for processing. Defaults to \code{1}.
#'
#' @return A list of lists, each sub-list containing multiple vectors representing
#'     the locations of cut sites for a given variant on a given sequence.
#'     Indexing the output list would be done as such:
#'     \code{output_list[[variant_index]][[sequence_index]][position_index]}.
#'
#' @noRd
#'
digest_var_set <- function(var_set_, bind_sites, len5s, chunk_size, n_cores = 1L) {
    .Call(`_gemino_digest_var_set`, var_set_, bind_sites, len5s, chunk_size, n_cores)
}

#' Internal C++ function to digest all sequences in a reference genome.
#'
#'
#'
#' @param ref_genome_ An external pointer to a C++ \code{RefGenome} object
#'     representing the reference genome.
#' @param bind_sites Vector of enzyme full recognition site(s).
#' @param len5s A vector of the numbers of characters of the prime5 sites for each
#'     recognition site.
#' @param chunk_size Size of chunks to break sequences into for processing.
#'     This value is ignored if it's set to zero.
#'     Ideally this is set to a value that results in a number of chunks divisible by
#'     the number of cores you're using, and is most useful when `n_cores` is greater
#'     than the number of scaffolds.
#'     Breaking into increasingly small chunks results in increasing overhead, so
#'     beware of making this argument very small.
#'     Reference genome sequences are not copied during this function, so using
#'     this argument for a reference genome does NOT decrease memory usage
#'     appreciably.
#'     Defaults to \code{0}.
#' @param n_cores The number of cores to use for processing. This value is ignored
#'     if the input reference genome is merged and \code{chunk_size == 0}.
#'     Defaults to \code{1}.
#'
#' @return A list of vectors, each vector representing the locations of cut sites
#'     on a given sequence.
#'     Indexing the output list would be done as such:
#'     \code{output_list[[sequence_index]][position_index]}.
#'
#' @noRd
#'
digest_ref <- function(ref_genome_, bind_sites, len5s, chunk_size = 0L, n_cores = 1L) {
    .Call(`_gemino_digest_ref`, ref_genome_, bind_sites, len5s, chunk_size, n_cores)
}

#' Estimates equilibrium nucleotide frequencies from an input rate matrix.
#'
#' It does this by solving for Ï€Q = 0 by finding the left eigenvector of Q that
#' corresponds to the eigenvalue closest to zero.
#' This is only needed for the UNREST model.
#'
#' @inheritParams Q UNREST_rate_matrix_
#' @inheritParams pi_tcag UNREST_rate_matrix_
#'
#' @noRd
#'
NULL

#' Q matrix for rates for a given nucleotide using the UNREST substitution model.
#'
#' This function also fills in a vector of equilibrium frequencies for each nucleotide.
#' This calculation has to be done for this model only because it uses separate
#' values for each non-diagonal cell and doesn't use equilibrium frequencies for
#' creating the matrix.
#'
#'
#' @param Q Matrix of substitution rates for "T", "C", "A", and "G", respectively.
#'     Do not include indel rates here! Diagonal values are ignored.
#' @param pi_tcag Empty vector of equilibrium frequencies for for "T", "C", "A", and "G",
#'     respectively. This vector will be filled in by this function.
#' @param xi Overall rate of indels.
#'
#' @noRd
#'
NULL

#' Q matrix for rates for a given nucleotide using the TN93 substitution model.
#'
#' @noRd
#'
TN93_rate_matrix <- function(pi_tcag, alpha_1, alpha_2, beta, xi) {
    .Call(`_gemino_TN93_rate_matrix`, pi_tcag, alpha_1, alpha_2, beta, xi)
}

#' Q matrix for rates for a given nucleotide using the JC69 substitution model.
#'
#' JC69 is a special case of TN93.
#'
#' @noRd
#'
JC69_rate_matrix <- function(lambda, xi) {
    .Call(`_gemino_JC69_rate_matrix`, lambda, xi)
}

#' Q matrix for rates for a given nucleotide using the K80 substitution model.
#'
#' K80 is a special case of TN93.
#'
#' @noRd
#'
K80_rate_matrix <- function(alpha, beta, xi) {
    .Call(`_gemino_K80_rate_matrix`, alpha, beta, xi)
}

#' Q matrix for rates for a given nucleotide using the F81 substitution model.
#'
#' F81 is a special case of TN93.
#'
#' @noRd
#'
F81_rate_matrix <- function(pi_tcag, xi) {
    .Call(`_gemino_F81_rate_matrix`, pi_tcag, xi)
}

#' Q matrix for rates for a given nucleotide using the HKY85 substitution model.
#'
#' HKY85 is a special case of TN93.
#'
#' @noRd
#'
HKY85_rate_matrix <- function(pi_tcag, alpha, beta, xi) {
    .Call(`_gemino_HKY85_rate_matrix`, pi_tcag, alpha, beta, xi)
}

#' Q matrix for rates for a given nucleotide using the F84 substitution model.
#'
#' F84 is a special case of TN93.
#'
#' @noRd
#'
F84_rate_matrix <- function(pi_tcag, beta, kappa, xi) {
    .Call(`_gemino_F84_rate_matrix`, pi_tcag, beta, kappa, xi)
}

#' Q matrix for rates for a given nucleotide using the GTR substitution model.
#'
#' @noRd
#'
GTR_rate_matrix <- function(pi_tcag, abcdef, xi) {
    .Call(`_gemino_GTR_rate_matrix`, pi_tcag, abcdef, xi)
}

#' Same as above, but it only takes a matrix and indel rate, and outputs a list.
#'
#' The list is of the standardized `Q` and the calculated `pi_tcag`.
#' This is for use in R.
#'
#' @inheritParams Q UNREST_rate_matrix
#' @inheritParams xi UNREST_rate_matrix
#'
#' @noRd
#'
#'
UNREST_rate_matrix <- function(Q, xi) {
    .Call(`_gemino_UNREST_rate_matrix`, Q, xi)
}

#' Add mutations manually from R.
#'
#' Note that all indices are in 0-based C++ indexing. This means that the first
#' item is indexed by `0`, and so forth.
#'
#' @param var_set_ External pointer to a C++ `VarSet` object
#' @param var_ind Integer index to the desired variant. Uses 0-based indexing!
#' @param seq_ind Integer index to the desired sequence. Uses 0-based indexing!
#' @param new_pos_ Integer index to the desired subsitution location.
#'     Uses 0-based indexing!
#'
#' @name add_mutations
NULL

#' Test sampling based on a evolutionary model.
#'
#' @noRd
#'
test_sampling <- function(var_set_, N, pi_tcag, alpha_1, alpha_2, beta, xi, psi, rel_insertion_rates, rel_deletion_rates, gamma_mat, chunk_size, display_progress = TRUE) {
    invisible(.Call(`_gemino_test_sampling`, var_set_, N, pi_tcag, alpha_1, alpha_2, beta, xi, psi, rel_insertion_rates, rel_deletion_rates, gamma_mat, chunk_size, display_progress))
}

#' Turns a VarGenome's mutations into a list of data frames.
#'
#' Temporary function for testing.
#'
#'
#' @noRd
#'
see_mutations <- function(var_set_, var_ind) {
    .Call(`_gemino_see_mutations`, var_set_, var_ind)
}

#' Turns a VarGenome's mutations into a list of data frames.
#'
#' Temporary function for testing.
#'
#'
#' @noRd
#'
examine_mutations <- function(var_set_, var_ind, seq_ind) {
    .Call(`_gemino_examine_mutations`, var_set_, var_ind, seq_ind)
}

#' Faster version of table function to count the number of mutations in Gamma regions.
#'
#' @param gamma_ends Vector of endpoints for gamma regions
#' @param positions Vector of positions that you want to bin into gamma regions.
#'
#'
#'
table_gammas <- function(gamma_ends, positions) {
    .Call(`_gemino_table_gammas`, gamma_ends, positions)
}

#' @describeIn add_mutations Add a substitution.
#'
#' @inheritParams var_set_ add_mutations
#' @inheritParams var_ind add_mutations
#' @inheritParams seq_ind add_mutations
#' @param nucleo_ Character to substitute for existing one.
#' @inheritParams new_pos_ add_mutations
#'
#'
add_substitution <- function(var_set_, var_ind, seq_ind, nucleo_, new_pos_) {
    invisible(.Call(`_gemino_add_substitution`, var_set_, var_ind, seq_ind, nucleo_, new_pos_))
}

#' @describeIn add_mutations Add an insertion.
#'
#' @inheritParams var_set_ add_mutations
#' @inheritParams var_ind add_mutations
#' @inheritParams seq_ind add_mutations
#' @param nucleos_ Nucleotides to insert at the desired location.
#' @inheritParams new_pos_ add_mutations
#'
#'
add_insertion <- function(var_set_, var_ind, seq_ind, nucleos_, new_pos_) {
    invisible(.Call(`_gemino_add_insertion`, var_set_, var_ind, seq_ind, nucleos_, new_pos_))
}

#' @describeIn add_mutations Add a deletion.
#'
#' @inheritParams var_set_ add_mutations
#' @inheritParams var_ind add_mutations
#' @inheritParams seq_ind add_mutations
#' @param size_ Size of deletion.
#' @inheritParams new_pos_ add_mutations
#'
#'
add_deletion <- function(var_set_, var_ind, seq_ind, size_, new_pos_) {
    invisible(.Call(`_gemino_add_deletion`, var_set_, var_ind, seq_ind, size_, new_pos_))
}

#' Get a rate for given start and end points of a VarSequence.
#'
#' @noRd
#'
test_rate <- function(start, end, var_ind, seq_ind, var_set_, sampler_) {
    .Call(`_gemino_test_rate`, start, end, var_ind, seq_ind, var_set_, sampler_)
}

#' Test sampling based on an evolutionary model.
#'
#' Make SURE `sampler_base_sexp` is a `ChunkMutationSampler`, not a `MutationSampler`!
#'
#' @param tip_labels Character vector of the actual phylogeny's tip labels.
#' @param ordered_tip_labels Character vector of the tip labels in the order
#'     you want them.
#'
#' @return A vector of integers indicating the number of mutations per edge.
#'
#' @noRd
#'
test_phylo <- function(var_set_, sampler_base_, seq_ind, branch_lens, edges, tip_labels, ordered_tip_labels, gamma_mat, recombination = FALSE, start = 0L, end = 0L) {
    .Call(`_gemino_test_phylo`, var_set_, sampler_base_, seq_ind, branch_lens, edges, tip_labels, ordered_tip_labels, gamma_mat, recombination, start, end)
}

#' Fill in vectors of mutation probabilities and lengths.
#'
#' These vectors should be initialized already, but there's no need to resize them.
#'
#'
#' @param Q A matrix of substitution rates for each nucleotide.
#' @param xi Overall rate of indels.
#' @param psi Proportion of insertions to deletions.
#' @param pi_tcag Vector of nucleotide equilibrium frequencies for
#'     "T", "C", "A", and "G", respectively.
#' @param rel_insertion_rates Relative insertion rates.
#' @param rel_deletion_rates Relative deletion rates.
#'
#' @noRd
#'
NULL

#' Creates MutationSampler without any of the pointers.
#'
#' `T` should be MutationSampler or ChunkMutationSampler
#' `T` should be LocationSampler or ChunkLocationSampler
#' MutationSampler should always go with LocationSampler, and
#' ChunkMutationSampler with ChunkLocationSampler
#'
#' Before actually using the object output from this function, make sure to...
#' * use `[Chunk]MutationSampler.fill_ptrs(VarSequence& var_seq)` to fill pointers.
#' * use `[Chunk]MutationSampler.fill_gamma(const arma::mat& gamma_mat)` to fill
#'   the gamma matrix.
#' * use `ChunkMutationSampler.location.change_chunk(chunk_size)` if using chunked
#'   version.
#'
#' @noRd
#'
NULL

make_mutation_sampler_base <- function(Q, xi, psi, pi_tcag, rel_insertion_rates, rel_deletion_rates) {
    .Call(`_gemino_make_mutation_sampler_base`, Q, xi, psi, pi_tcag, rel_insertion_rates, rel_deletion_rates)
}

make_mutation_sampler_chunk_base <- function(Q, xi, psi, pi_tcag, rel_insertion_rates, rel_deletion_rates, chunk_size) {
    .Call(`_gemino_make_mutation_sampler_chunk_base`, Q, xi, psi, pi_tcag, rel_insertion_rates, rel_deletion_rates, chunk_size)
}

#' Function to print info on a `RefGenome`.
#'
#' Access `RefGenome` class's print method from R.
#'
#' @noRd
#'
print_ref_genome <- function(ref_genome_) {
    invisible(.Call(`_gemino_print_ref_genome`, ref_genome_))
}

#' Function to print info on a VarSet.
#'
#' Access `VarSet` class's print method from R.
#'
#' @noRd
#'
print_var_set <- function(var_set_) {
    invisible(.Call(`_gemino_print_var_set`, var_set_))
}

#' Calculate mean pairwise differences between samples using a vector of nucleotide
#'     frequencies.
#'
#'
#' @param sample_segr Vector of nucleotide frequencies at a given segregating site for
#'     all samples.
#'
#' @return Mean of the pairwise differences.
#'
#' @noRd
#'
NULL

#' Iterate and mutate one sequence.
#'
#' @noRd
#'
NULL

#' Get a reference genome sequence's size.
#'
#' @noRd
#'
see_ref_seq_size <- function(ref_genome_, s) {
    .Call(`_gemino_see_ref_seq_size`, ref_genome_, s)
}

#' Get number of sequences in a reference genome.
#'
#' @noRd
#'
see_ref_n_seq <- function(ref_genome_) {
    .Call(`_gemino_see_ref_n_seq`, ref_genome_)
}

#' Compute absolute difference between expected and desired segregated-site divergence
#'
#'
#' This function is to get the value of the two beta-distribution shapes that
#' minimize the absolute difference between the expected and desired segregated-site
#' divergence (i.e., mean pairwise differences).
#' It is used in the R function `freq_probs` during the optimization step.
#'
#' @noRd
#'
optim_prob <- function(v, mean_pws_, dens_, seg_div_) {
    .Call(`_gemino_optim_prob`, v, mean_pws_, dens_, seg_div_)
}

#' Randomly choose sequences for segregating sites, weighted based on sequence length.
#'
#' This function is used separately for indels and SNPs.
#'
#' The indices of the output matrix coincide with the order of sequences in the
#' \code{dna_set} input to \code{make_variants}.
#'
#' This function does NOT return an error if a sequence is chosen more times
#' than its length.
#'
#' @param total_mutations The total number of mutations (SNPs and indels).
#' @param seq_lens A vector of the sequence lengths.
#' @param seeds A vector seeds for the prng.
#'
#'
#' @return A numeric vector containing the number of mutations per sequence.
#'
#' @noRd
#'
sample_seqs <- function(total_mutations, seq_lens, n_cores) {
    .Call(`_gemino_sample_seqs`, total_mutations, seq_lens, n_cores)
}

#' Get possible nucleotide distributions and their pairwise differences.
#'
#' Retrieve all combinations (with replacement) of nucleotide distributions that sum
#' to \code{N}, and, for each, calculate \eqn{\pi_{ji}}.
#'
#'
#' @param N Total number of individuals the frequencies must add to.
#'
#' @return List consisting of a matrix and a vector.
#'     The matrix (\code{List$combos}) contains all nucleotide frequencies that add
#'     to \code{N} (by row).
#'     The vector (\code{List$mean_pws}) contains the mean pairwise differences
#'     for a segregating site comprised of nucleotide frequencies present in each row
#'     of the matrix.
#'     For example, a segregating site for 10 haploid samples containing 3 As, 3 Cs,
#'     2 Gs, and 2 Ts would have a mean pairwise difference of 0.8222222.
#'
#' @noRd
#'
cpp_nt_freq <- function(N) {
    .Call(`_gemino_cpp_nt_freq`, N)
}

#' Inner function to create a C++ \code{VarSet} object
#'
#'
#' @param n_mutations Integer vector of the total number of mutations (SNPs or indels)
#'     for each sequence.
#' @param ref_genome_ External pointer to a C++ \code{SequenceSet} object that
#'     represents the reference genome.
#' @param snp_combo_list Matrix of all possible nucleotide combinations among all
#'     variants per SNP.
#' @param snp_probs_cumsum Vector of sampling probabilities for each row in
#'     \code{snp_combo_list}.
#' @param seeds Vector of seeds, the length of which dictates how many cores will be
#'     used.
#' @param snp_p Proportion of mutations that are SNPs. Defaults to 0.9.
#' @param insertion_p Proportion of \emph{indels} that are insertions. Defaults to 0.5.
#' @param n2N A numeric threshold placed on the algorithm used to find new locations.
#'     This is not recommended to be changed. Defaults to 50.
#' @param alpha A numeric threshold placed on the algorithm used to find new locations.
#'     This is not recommended to be changed. Defaults to 0.8.
#'
#'
#' @return An external pointer to a \code{VarSet} object in C++.
#'
#' @noRd
#'
make_variants_ <- function(n_mutations, ref_genome_, snp_combo_list, mutation_probs, mutation_types, mutation_sizes, n_cores, n2N = 50, alpha = 0.8) {
    .Call(`_gemino_make_variants_`, n_mutations, ref_genome_, snp_combo_list, mutation_probs, mutation_types, mutation_sizes, n_cores, n2N, alpha)
}

#' Read a non-indexed fasta file to a \code{RefGenome} object.
#'
#' @param file_name File name of the fasta file.
#' @param cut_names Boolean for whether to cut sequence names at the first space.
#'     Defaults to \code{TRUE}.
#' @param remove_soft_mask Boolean for whether to remove soft-masking by making
#'    sequences all uppercase. Defaults to \code{TRUE}.
#'
#' @return Nothing.
#'
#' @noRd
#'
read_fasta_noind <- function(fasta_file, cut_names, remove_soft_mask) {
    .Call(`_gemino_read_fasta_noind`, fasta_file, cut_names, remove_soft_mask)
}

#' Read an indexed fasta file to a \code{RefGenome} object.
#'
#' @param file_name File name of the fasta file.
#' @param remove_soft_mask Boolean for whether to remove soft-masking by making
#'    sequences all uppercase. Defaults to \code{TRUE}.
#' @param offsets Vector of sequence offsets from the fasta index file.
#' @param names Vector of sequence names from the fasta index file.
#' @param lengths Vector of sequence lengths from the fasta index file.
#' @param line_lens Vector of sequence line lengths from the fasta index file.
#'
#' @return Nothing.
#'
#' @noRd
#'
#'
read_fasta_ind <- function(fasta_file, fai_file, remove_soft_mask) {
    .Call(`_gemino_read_fasta_ind`, fasta_file, fai_file, remove_soft_mask)
}

#' Write \code{RefGenome} to an uncompressed fasta file.
#'
#' @param file_name File name of output fasta file.
#' @param ref_ An external pointer to a \code{RefGenome} C++ object.
#' @param text_width The number of characters per line in the output fasta file.
#'
#' @return Nothing.
#'
#' @noRd
#'
#'
write_fasta_fa <- function(file_name, ref_, text_width) {
    invisible(.Call(`_gemino_write_fasta_fa`, file_name, ref_, text_width))
}

#' Write \code{RefGenome} to a compressed fasta file.
#'
#' @inheritParams write_fasta_fa
#'
#' @return Nothing.
#'
#' @noRd
#'
write_fasta_gz <- function(file_name, ref_, text_width) {
    invisible(.Call(`_gemino_write_fasta_gz`, file_name, ref_, text_width))
}

#' Make a VarSet object from a set of sequences and # variants
#'
#' @noRd
make_var_set <- function(seqs, n_vars) {
    .Call(`_gemino_make_var_set`, seqs, n_vars)
}

#' Function to piece together the strings for all sequences in a VarGenome.
#'
#' @noRd
see_var_genome <- function(var_set_, var_ind) {
    .Call(`_gemino_see_var_genome`, var_set_, var_ind)
}

#' See all sequence sizes in a VarSet object.
#'
#' @noRd
see_sizes <- function(var_set_, var_ind) {
    .Call(`_gemino_see_sizes`, var_set_, var_ind)
}

#' Pr(S == s).
#'
#'
#' @noRd
NULL

#' Pr(S <= s)
#'
#' @noRd
#'
NULL

#' var(S).
#'
#' @noRd
#'
NULL

#' Expected value of S.
#'
#' If comparing distances to S, remember that S in Vitter's paper is the number of
#' positions to skip _before_ taking the next one, so it should be 1 less than the
#' distance.
#' So just add 1 to this function to get expected distances.
#'
#' @noRd
#'
NULL

test_vitter_d <- function(reps, n, N, n_cores, n2N = 50, alpha = 0.8) {
    .Call(`_gemino_test_vitter_d`, reps, n, N, n_cores, n2N, alpha)
}

